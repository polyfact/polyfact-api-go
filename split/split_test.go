package split

import (
	"fmt"
	"reflect"
	"testing"
)

func TestSplitSimple(t *testing.T) {
	got1, got2 := Split("hellomynameislancelot")
	want1 := "hellomynam"
	want2 := "eislancelot"

	if got1 != want1 || got2 != want2 {
		t.Errorf("got (%v, %v) wanted (%v, %v)", got1, got2, want1, want2)
	}
}

func TestSplitSimple2(t *testing.T) {
	got1, got2 := Split("hello,\nmynameislancelot")
	want1 := "hello,"
	want2 := "\nmynameislancelot"

	if got1 != want1 || got2 != want2 {
		t.Errorf("got (%v, %v) wanted (%v, %v)", got1, got2, want1, want2)
	}
}

func TestSplitSimple3(t *testing.T) {
	got1, got2 := Split("hello,\n\nmynamei\nslancelot")
	want1 := "hello,"
	want2 := "\n\nmynamei\nslancelot"

	if got1 != want1 || got2 != want2 {
		t.Errorf("got (%v, %v) wanted (%v, %v)", got1, got2, want1, want2)
	}
}

func TestSplitSimple4(t *testing.T) {
	got1, got2 := Split("hello,\n\n\tmynam\n\n\teislancelot")
	want1 := "hello,"
	want2 := "\n\n\tmynam\n\n\teislancelot"

	if got1 != want1 || got2 != want2 {
		t.Errorf("got (%v, %v) wanted (%v, %v)", got1, got2, want1, want2)
	}
}

func TestBinarySplit(t *testing.T) {
	res := BinarySplit("According to all known laws of aviation, there is no way that a bee should be able to fly.\nIts wings are too small to get its fat little body off the ground.\nThe bee, of course, flies anyway. Because bees don’t care what humans think is impossible.”\n\nSEQ. 75 - “INTRO TO BARRY”\nINT. BENSON HOUSE - DAY ANGLE ON: Sneakers on the ground.\nCamera PANS UP to reveal BARRY BENSON’S BEDROOM ANGLE ON:", 10)
	want := []string{
		"According to all known laws of aviation, there",
		" is no way that a bee",
		" should be able to fly.",
		"\nIts wings are too small to get its",
		" fat little body off the ground.",
		"\nThe bee, of course, flies",
		" anyway. Because bees",
		" don’t care what humans think is impossible.”",
		"\n\nSEQ. 75 - “INTRO",
		" TO BARRY”",
		"\nINT. BENSON",
		" HOUSE - DAY ANGLE",
		" ON: Sneakers on the ground.",
		"\nCamera PANS UP to reveal BARRY",
		" BENSON’S BEDROOM ANGLE ON:",
	}

	if !reflect.DeepEqual(res, want) {
		t.Errorf("got (%v) wanted (%v)", res, want)
	}
}

func TestGenerateWithSplit(t *testing.T) {
	type_format := make(map[string]interface{})
	type_format["function_names"] = make([]interface{}, 1)
	type_format["function_names"].([]interface{})[0] = "string"
	res, err := GenerateWithSplit(type_format, "Extract all the names of the functions defined in this file. Don't include functions that are defined in this file: ```\nuse crate::consts::CPU_CYCLE_LENGTH_NANOS;\nuse crate::state::{flag, reg, GBState, MemError};\nuse std::{thread, time};\n\npub fn r_16b_from_pc(state: &mut GBState) -> Result<u16, MemError> {\n    let p: u16 = state.mem.r(state.cpu.pc)? as u16 | ((state.mem.r(state.cpu.pc + 1)? as u16) << 8);\n    state.cpu.pc += 2;\n\n    Ok(p)\n}\n\npub fn r_8b_from_pc(state: &mut GBState) -> Result<u8, MemError> {\n    let p = state.mem.r(state.cpu.pc)?;\n    state.cpu.pc += 1;\n\n    Ok(p)\n}\n\npub fn ldrr(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    // Load a register into another register\n    // LD r, r\n    state.w_reg(n1, state.r_reg(n2)?)\n}\n\npub fn ldr8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Load an raw 8b value into a register\n    let p = r_8b_from_pc(state)?;\n\n    state.w_reg(n1, p)?;\n    Ok(8)\n}\n\npub fn ldrr16(state: &mut GBState, rr: u8, x: u16) {\n    // Load a raw 16b value into a register\n    state.cpu.w16(rr, x);\n}\n\npub fn ldnnsp(state: &mut GBState) -> Result<u64, MemError> {\n    // Load SP into an arbitrary position in memory\n    let p = r_16b_from_pc(state)?;\n\n    state.mem.w(p, (state.cpu.sp & 0xff) as u8)?;\n    state.mem.w(p + 1, (state.cpu.sp >> 8) as u8)?;\n    Ok(20)\n}\n\npub fn ldsphl(state: &mut GBState) -> u64 {\n    state.cpu.sp = state.cpu.r16(reg::HL);\n    8\n}\n\npub fn ldnna(state: &mut GBState, nn: u16) -> Result<(), MemError> {\n    // Load A into an arbitrary position in memory\n    state.mem.w(nn, state.cpu.r[reg::A as usize])?;\n    Ok(())\n}\n\npub fn ldann(state: &mut GBState, nn: u16) -> Result<(), MemError> {\n    // Load A from an arbitrary position in memory\n    state.cpu.r[reg::A as usize] = state.mem.r(nn)?;\n    Ok(())\n}\n\npub fn push(state: &mut GBState, x: u16) -> Result<(), MemError> {\n    state.cpu.sp -= 2;\n\n    state.mem.w(state.cpu.sp, (x & 0xff) as u8)?;\n\n    state.mem.w(state.cpu.sp + 1, (x >> 8) as u8)?;\n\n    Ok(())\n}\n\npub fn pop(state: &mut GBState) -> Result<u16, MemError> {\n    let res = state.mem.r(state.cpu.sp)? as u16 | ((state.mem.r(state.cpu.sp + 1)? as u16) << 8);\n\n    state.cpu.sp += 2;\n\n    Ok(res)\n}\n\npub fn jr8(state: &mut GBState) -> Result<u64, MemError> {\n    // Unconditional relative jump\n    let p = r_8b_from_pc(state)?;\n\n    state.cpu.pc = (state.cpu.pc as i16 + p as i8 as i16) as u16;\n\n    Ok(12)\n}\n\npub fn jrcc8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Conditional relative jump\n    let p = r_8b_from_pc(state)?;\n    let mut cycles = 8;\n\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 4;\n        state.cpu.pc = (state.cpu.pc as i16 + p as i8 as i16) as u16;\n    }\n\n    Ok(cycles)\n}\n\npub fn jp16(state: &mut GBState) -> Result<u64, MemError> {\n    // Unconditional absolute jump\n    let p = r_16b_from_pc(state)?;\n\n    state.cpu.pc = p;\n\n    Ok(16)\n}\n\npub fn jphl(state: &mut GBState) -> u64 {\n    // Unconditional absolute jump to HL\n    state.cpu.pc = state.cpu.r16(reg::HL);\n\n    4\n}\n\npub fn jpcc16(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Conditional absolute jump\n    let p = r_16b_from_pc(state)?;\n    let mut cycles = 8;\n\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 4;\n        state.cpu.pc = p;\n    }\n\n    Ok(cycles)\n}\n\npub fn call(state: &mut GBState) -> Result<u64, MemError> {\n    // Unconditional function call\n    let p = r_16b_from_pc(state)?;\n\n    push(state, state.cpu.pc)?;\n    state.cpu.pc = p;\n\n    Ok(24)\n}\n\npub fn callcc(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Conditional function call\n    let p = r_16b_from_pc(state)?;\n    let mut cycles = 12;\n\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 12;\n        push(state, state.cpu.pc)?;\n        state.cpu.pc = p;\n    }\n\n    Ok(cycles)\n}\n\npub fn ret(state: &mut GBState) -> Result<u64, MemError> {\n    state.cpu.pc = pop(state)?;\n\n    if state.cpu.pc == 0 {\n        panic!(\"RET to start\");\n    }\n    Ok(16)\n}\n\npub fn retcc(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    let mut cycles = 8;\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 12;\n        state.cpu.pc = pop(state)?;\n    }\n\n    Ok(cycles)\n}\n\npub fn ld00a(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Load register A into or from memory pointed by rr (BC, DE or HL(+/-))\n    // LD (rr), A\n    // LD A, (rr)\n    let ptr_reg = match n1 & 0b110 {\n        0b000 => reg::B,\n        0b010 => reg::C,\n        _ => reg::HL,\n    };\n\n    if n1 & 0b001 == 1 {\n        state.cpu.r[reg::A as usize] = state.mem.r(state.cpu.r16(ptr_reg))?;\n    } else {\n        state\n            .mem\n            .w(state.cpu.r16(ptr_reg), state.cpu.r[reg::A as usize])?;\n    }\n\n    if n1 & 0b110 == 0b100 {\n        state.cpu.w16(reg::HL, state.cpu.r16(reg::HL) + 1); // (HL+)\n    }\n\n    if n1 & 0b110 == 0b110 {\n        state.cpu.w16(reg::HL, state.cpu.r16(reg::HL) - 1); // (HL-)\n    }\n\n    Ok(8)\n}\n\npub fn inc8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Increment 8 bit register\n    state.w_reg(n1, state.r_reg(n1)? + 1)?;\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::ZF | flag::H);\n    if state.r_reg(n1)? == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.r_reg(n1)? & 0xf == 0x0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    Ok(4)\n}\n\npub fn dec8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Decrement 8 bit register\n    state.w_reg(n1, state.r_reg(n1)? - 1)?;\n    state.cpu.r[reg::F as usize] |= flag::N;\n\n    state.cpu.r[reg::F as usize] &= !(flag::ZF | flag::H);\n    if state.r_reg(n1)? == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.r_reg(n1)? & 0xf == 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    Ok(4)\n}\n\npub fn inc16(state: &mut GBState, rr: u8) -> u64 {\n    // Increment 16 bit register\n    state.cpu.w16(rr, state.cpu.r16(rr) + 1);\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::ZF | flag::H);\n\n    if state.cpu.r16(rr) == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.cpu.r16(rr) & 0xff == 0x0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n    8\n}\n\npub fn dec16(state: &mut GBState, rr: u8) -> u64 {\n    // Decrement 16 bit register\n    state.cpu.w16(rr, state.cpu.r16(rr) - 1);\n    state.cpu.r[reg::F as usize] |= flag::N;\n\n    state.cpu.r[reg::F as usize] &= !(flag::ZF | flag::H);\n    if state.cpu.r16(rr) == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.cpu.r16(rr) & 0xff == 0xff {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n    8\n}\n\npub fn ccf(state: &mut GBState) {\n    // Flip carry flag\n    state.cpu.r[reg::F as usize] = (state.cpu.r[reg::F as usize] & 0b10011111) ^ 0b00010000\n}\n\npub fn scf(state: &mut GBState) {\n    // Set carry flag\n    state.cpu.r[reg::F as usize] = (state.cpu.r[reg::F as usize] & 0b10011111) | 0b00010000\n}\n\npub fn daa(state: &mut GBState) {\n    // Decimal Adjust Accumulator\n    // Adjust the A register after a addition or substraction to keep valid BCD representation\n    let nibble_low = state.cpu.r[reg::A as usize] & 0b1111;\n    let nibble_high = state.cpu.r[reg::A as usize] >> 4;\n    let sub_flag = (state.cpu.r[reg::F as usize] & flag::N) != 0;\n    let half_carry_flag = (state.cpu.r[reg::F as usize] & flag::H) != 0;\n\n    if (half_carry_flag || nibble_low > 9) && !sub_flag {\n        state.cpu.r[reg::A as usize] += 0x06;\n    }\n    if (half_carry_flag || nibble_low > 9) && sub_flag {\n        state.cpu.r[reg::A as usize] -= 0x06;\n    }\n\n    if nibble_high > 9 && !sub_flag {\n        state.cpu.r[reg::A as usize] += 0x60;\n        state.cpu.r[reg::F as usize] += flag::CY;\n    }\n    if nibble_high > 9 && sub_flag {\n        state.cpu.r[reg::A as usize] -= 0x60;\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.cpu.r[reg::F as usize] &= !flag::H;\n}\n\npub fn cpl(state: &mut GBState) {\n    // Flip all bits in register A\n    state.cpu.r[reg::F as usize] = state.cpu.r[reg::F as usize] & 0b10011111;\n    state.cpu.r[reg::A as usize] ^= 0xff;\n}\n\npub fn addsp8(state: &mut GBState) -> Result<u64, MemError> {\n    let n = r_8b_from_pc(state)? as i8;\n\n    state.cpu.sp = (state.cpu.sp as i32 + n as i32) as u16;\n\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::H | flag::CY);\n\n    if (state.cpu.sp & 0xff) as i32 + n as i32 & !0xff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if (state.cpu.sp as i32 + n as i32) & !0xffff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n    Ok(16)\n}\n\npub fn add(state: &mut GBState, x: u8) {\n    // ADD a number to A and store the result in A\n    let res = x as u16 + state.cpu.r[reg::A as usize] as u16;\n\n    state.cpu.r[reg::A as usize] = res as u8;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if (x & 0xf) + (state.cpu.r[reg::A as usize] & 0xf) > 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if res > 0xff {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn addhlrr(state: &mut GBState, rr: u8) -> u64 {\n    let n = state.cpu.r16(rr);\n    let hl = state.cpu.r16(reg::HL);\n\n    state.cpu.w16(reg::HL, (hl as i32 + n as i32) as u16);\n\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::H | flag::CY);\n\n    if (hl & 0xff) as i32 + n as i32 & !0xff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if (hl as i32 + n as i32) & !0xffff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    8\n}\n\npub fn adc(state: &mut GBState, x: u8) {\n    // ADD a number and the carry flag to A and store the result in A\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n    let res = x as u16 + state.cpu.r[reg::A as usize] as u16 + carry as u16;\n\n    state.cpu.r[reg::A as usize] = res as u8;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if (x & 0xf) + ((state.cpu.r[reg::A as usize] & 0xf) + carry) > 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if res > 0xff {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn sub(state: &mut GBState, x: u8) {\n    // SUB a number to A and store the result in A\n    state.cpu.r[reg::F as usize] = flag::N;\n\n    if (x & 0xf) > (state.cpu.r[reg::A as usize] & 0xf) {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if x > state.cpu.r[reg::A as usize] {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    state.cpu.r[reg::A as usize] = state.cpu.r[reg::A as usize] - x;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn sbc(state: &mut GBState, x: u8) {\n    // SUB a number and the carry flag to A and store the result in A\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n    state.cpu.r[reg::F as usize] = flag::N;\n\n    if (x & 0xf) > (state.cpu.r[reg::A as usize] & 0xf) - carry {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if x > state.cpu.r[reg::A as usize] - carry {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    state.cpu.r[reg::A as usize] = state.cpu.r[reg::A as usize] - x - carry;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn and(state: &mut GBState, x: u8) {\n    // AND a number to A and store the result in A\n    state.cpu.r[reg::A as usize] &= x;\n\n    state.cpu.r[reg::F as usize] = flag::H;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn xor(state: &mut GBState, x: u8) {\n    // XOR a number to A and store the result in A\n    state.cpu.r[reg::A as usize] ^= x;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn or(state: &mut GBState, x: u8) {\n    // OR a number to A and store the result in A\n    state.cpu.r[reg::A as usize] |= x;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn cp(state: &mut GBState, x: u8) {\n    // SUB a number to A and update the flags accordingly without updating A\n    state.cpu.r[reg::F as usize] |= flag::N;\n\n    if x & 0xf > state.cpu.r[reg::A as usize] & 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if x > state.cpu.r[reg::A as usize] {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    let res = state.cpu.r[reg::A as usize] - x;\n\n    if res == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn rlc(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE LEFT the input register\n    let mut n = state.r_reg(r_i)?;\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n >> 7) << 4;\n    n <<= 1;\n    n |= (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n    state.w_reg(r_i, n)\n}\n\npub fn rrc(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE RIGHT the input register\n    let mut n = state.r_reg(r_i)?;\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 1) << 4;\n    n >>= 1;\n    n |= ((state.cpu.r[reg::F as usize] & flag::CY) >> 4) << 7;\n    state.w_reg(r_i, n)\n}\n\npub fn rl(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE LEFT THROUGH CARRY the input register\n    let mut n = state.r_reg(r_i)?;\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n >> 7) << 4;\n    n <<= 1;\n    n |= carry;\n    state.w_reg(r_i, n)\n}\n\npub fn rr(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE RIGHT THROUGH CARRY the input register\n    let mut n = state.r_reg(r_i)?;\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 1) << 4;\n    n >>= 1;\n    n |= carry << 7;\n    state.w_reg(r_i, n)\n}\n\npub fn sla(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Shift left Arithmetic (b0=0) the input register\n    let mut n = state.r_reg(r_i)?;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n >> 7) << 4;\n    n <<= 1;\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}\n\npub fn sra(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Shift right Arithmetic (b7=b7) the input register\n    let mut n = state.r_reg(r_i)?;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 0b1) << 4;\n    let b7 = n & 0b10000000;\n    n >>= 1;\n    n |= b7;\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}\n\npub fn swap(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Swap the high nibble and low nibble\n    let mut n = state.r_reg(r_i)?;\n\n    let nibble_low = n & 0b1111;\n    let nibble_high = n >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n\n    n = nibble_high | (nibble_low << 4);\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}\n\npub fn srl(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Shift right Logical (b7=0) the input register\n    let mut n = state.r_reg(r_i)?;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 0b1) << 4;\n    n >>= 1;\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}\n\npub fn bit(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    let z = (((state.r_reg(n2)? >> n1) & 1) ^ 1) << 7;\n\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::ZF);\n    state.cpu.r[reg::F as usize] |= flag::H | z;\n    Ok(())\n}\n\npub fn set(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    state.w_reg(n2, state.r_reg(n2)? | (1 << n1))\n}\n\npub fn res(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    state.w_reg(n2, state.r_reg(n2)? & !(1 << n1))\n}\n\npub fn op00(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    // Dispatcher for the instructions starting with 0b00 based on their 3 LSB\n    match n2 {\n        0b000 => match n1 {\n            0b000 => Ok(4),\n            0b001 => ldnnsp(state),\n            0b010 => todo!(\"STOP\"), // STOP\n            0b011 => jr8(state),\n            _ => jrcc8(state, n1),\n        },\n        0b001 => match n1 {\n            0b001 | 0b011 | 0b101 | 0b111 => Ok(addhlrr(state, n1 >> 1)),\n            0b000 | 0b010 | 0b100 | 0b110 => {\n                let p = r_16b_from_pc(state)?;\n                ldrr16(state, n1 >> 1, p);\n                Ok(12)\n            }\n            _ => panic!(),\n        },\n        0b010 => ld00a(state, n1),\n        0b011 => match n1 {\n            0b001 | 0b011 | 0b101 | 0b111 => Ok(dec16(state, n1 >> 1)),\n            0b000 | 0b010 | 0b100 | 0b110 => Ok(inc16(state, n1 >> 1)),\n            _ => panic!(),\n        },\n        0b100 => inc8(state, n1),\n        0b101 => dec8(state, n1),\n        0b110 => ldr8(state, n1),\n        0b111 => {\n            match n1 {\n                0b000 => rlc(state, 7)?,\n                0b001 => rrc(state, 7)?,\n                0b010 => rl(state, 7)?,\n                0b011 => rr(state, 7)?,\n                0b100 => daa(state),\n                0b101 => cpl(state),\n                0b110 => scf(state),\n                0b111 => ccf(state),\n                _ => panic!(),\n            };\n            Ok(4)\n        }\n        _ => panic!(),\n    }\n}\n\npub fn op01(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    // Dispatcher for the instructions starting with 0b01 (LD r,r and HALT)\n    if n1 == 0b110 && n2 == 0b110 {\n        todo!(\"HALT\")\n    } else {\n        ldrr(state, n1, n2)?;\n\n        if n1 == 0b110 || n2 == 0b110 {\n            Ok(8)\n        } else {\n            Ok(4)\n        }\n    }\n}\n\npub fn op10(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    // Dispatcher for the instructions starting with 0b10 (Arithmetic)\n    match n1 {\n        0b000 => add(state, state.r_reg(n2)?),\n        0b001 => adc(state, state.r_reg(n2)?),\n        0b010 => sub(state, state.r_reg(n2)?),\n        0b011 => sbc(state, state.r_reg(n2)?),\n        0b100 => and(state, state.r_reg(n2)?),\n        0b101 => xor(state, state.r_reg(n2)?),\n        0b110 => or(state, state.r_reg(n2)?),\n        0b111 => cp(state, state.r_reg(n2)?),\n        _ => panic!(),\n    }\n\n    if n2 == 0b110 {\n        Ok(8)\n    } else {\n        Ok(4)\n    }\n}\n\npub fn op11(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    match n2 {\n        0b000 => match n1 {\n            0b100 => {\n                let n = r_8b_from_pc(state)?;\n                ldnna(state, n as u16 | 0xff00)?;\n                Ok(12)\n            }\n            0b101 => addsp8(state),\n            0b110 => {\n                let n = r_8b_from_pc(state)?;\n                ldann(state, n as u16 | 0xff00)?;\n                Ok(12)\n            }\n            0b111 => {\n                let n = r_8b_from_pc(state)?;\n                ldrr16(state, reg::HL, n as u16 + state.cpu.sp);\n                Ok(12)\n            }\n            _ => retcc(state, n1 & 0b11),\n        },\n        0b001 => match n1 {\n            0b001 => ret(state),\n            0b011 => {\n                state.ime = true;\n\n                ret(state)\n            }\n            0b101 => Ok(jphl(state)),\n            0b111 => Ok(ldsphl(state)),\n            _ => {\n                let p = pop(state)?;\n                state.cpu.r[(n1 >> 1) as usize * 2 + 1] = (p & 0xff) as u8;\n                state.cpu.r[(n1 >> 1) as usize * 2] = (p >> 8) as u8;\n                Ok(12)\n            }\n        },\n        0b010 => match n1 {\n            0b100 => {\n                ldnna(state, state.cpu.r[reg::C as usize] as u16 | 0xff00)?;\n                Ok(8)\n            }\n            0b101 => {\n                let nn = r_16b_from_pc(state)?;\n                ldnna(state, nn)?;\n                Ok(16)\n            }\n            0b110 => {\n                ldann(state, state.cpu.r[reg::C as usize] as u16 | 0xff00)?;\n                Ok(8)\n            }\n            0b111 => {\n                let nn = r_16b_from_pc(state)?;\n                ldann(state, nn)?;\n                Ok(16)\n            }\n            _ => jpcc16(state, n1 & 0b11),\n        },\n        0b011 => match n1 {\n            0b000 => jp16(state),\n            0b001 => op_bitwise(state), // Bitwise operations\n            0b010 | 0b011 | 0b100 | 0b101 => unimplemented!(),\n            0b110 => {\n                state.ime = false;\n                Ok(4)\n            }\n            0b111 => {\n                state.ime = true;\n                Ok(4)\n            }\n            _ => panic!(),\n        },\n        0b100 => callcc(state, n1 & 0b11),\n        0b101 => match n1 {\n            0b001 => call(state),\n            0b011 | 0b101 | 0b111 => unimplemented!(),\n            _ => {\n                let value = state.cpu.r[(n1 >> 1) as usize * 2 + 1] as u16\n                    | ((state.cpu.r[(n1 >> 1) as usize * 2] as u16) << 8);\n                push(state, value)?;\n                Ok(16)\n            }\n        },\n        0b110 => {\n            let p = r_8b_from_pc(state)?;\n\n            match n1 {\n                0b000 => add(state, p),\n                0b001 => adc(state, p),\n                0b010 => sub(state, p),\n                0b011 => sbc(state, p),\n                0b100 => and(state, p),\n                0b101 => xor(state, p),\n                0b110 => or(state, p),\n                0b111 => cp(state, p),\n                _ => panic!(),\n            }\n            Ok(8)\n        }\n        0b111 => {\n            let p = n1 << 3;\n\n            push(state, state.cpu.pc)?;\n            state.cpu.pc = p as u16;\n            Ok(16)\n        } // RST\n        _ => panic!(),\n    }\n}\n\npub fn op_bitwise(state: &mut GBState) -> Result<u64, MemError> {\n    let p = r_8b_from_pc(state)?;\n    let opcode = p >> 6;\n    let n1 = p >> 3 & 0b111;\n    let n2 = p & 0b111;\n\n    match opcode {\n        0b00 => match n1 {\n            0b000 => rlc(state, n2),\n            0b001 => rrc(state, n2),\n            0b010 => rl(state, n2),\n            0b011 => rr(state, n2),\n            0b100 => sla(state, n2),\n            0b101 => sra(state, n2),\n            0b110 => swap(state, n2),\n            0b111 => srl(state, n2),\n            _ => panic!(),\n        },\n        0b01 => bit(state, n1, n2),\n        0b10 => res(state, n1, n2),\n        0b11 => set(state, n1, n2),\n        _ => panic!(),\n    };\n    if n2 == 0b110 {\n        Ok(16)\n    } else {\n        Ok(8)\n    }\n}\n```", nil, 1000)
	fmt.Printf("%v %v\n", res, err)
}
