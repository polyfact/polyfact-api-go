package split

import (
	"fmt"
	"testing"
)

func TestExtract(t *testing.T) {
	// t.Skip("Skipping LLM call test")
	b_splits := ExtractTaskFromSplits(BinarySplit("\n	Examine the provided content from file `{path}` :\n```\npackage main\n\nimport (\n	\"context\"\n	\"encoding/json\"\n	\"fmt\"\n	\"log\"\n	\"net/http\"\n	\"os\"\n\n	jwt \"github.com/golang-jwt/jwt/v5\"\n	db \"github.com/polyfact/api/db\"\n	llm \"github.com/polyfact/api/llm\"\n	split \"github.com/polyfact/api/split\"\n)\n\ntype GenerateRequestBody struct {\n	Task       string `json:\"task\"`\n	ReturnType any    `json:\"return_type\"`\n}\n\nfunc generate(w http.ResponseWriter, r *http.Request) {\n	user_id := r.Context().Value(\"user_id\").(string)\n\n	if r.Method != \"POST\" {\n		http.Error(w, \"405 method not allowed\", http.StatusMethodNotAllowed)\n		return\n	}\n\n	if len(r.Header[\"Content-Type\"]) == 0 || r.Header[\"Content-Type\"][0] != \"application/json\" {\n		http.Error(w, \"400 bad request\", http.StatusBadRequest)\n		return\n	}\n\n	var input GenerateRequestBody\n\n	err := json.NewDecoder(r.Body).Decode(&input)\n	if err != nil {\n		http.Error(w, \"400 bad request\", http.StatusBadRequest)\n		return\n	}\n\n	callback := func(model_name string, input_count int, output_count int) {\n		db.LogRequests(user_id, model_name, input_count, output_count)\n	}\n\n	result, err := llm.Generate(input.ReturnType, input.Task, &callback)\n\n	w.Header()[\"Content-Type\"] = []string{\"application/json\"}\n\n	fmt.Printf(\"AAA %v\", split.Split\n\n	if err != nil {\n		w.WriteHeader(500)\n		w.Write([]byte(result.Result.(string)))\n		return\n	}\n\n	json.NewEncoder(w).Encode(result)\n}\n\nfunc authMiddleware(handler func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) {\n	return func(w http.ResponseWriter, r *http.Request) {\n		if len(r.Header[\"X-Access-Token\"]) == 0 {\n			http.Error(w, \"403 forbidden\", http.StatusForbidden)\n			return\n		}\n		access_token := r.Header[\"X-Access-Token\"][0]\n\n		token, err := jwt.Parse(access_token, func(token *jwt.Token) (interface{}, error) {\n			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n				return nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n			}\n\n			return []byte(os.Getenv(\"JWT_SECRET\")), nil\n		})\n\n		var user_id string\n\n		if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid && err == nil {\n			user_id = claims[\"user_id\"].(string)\n		} else {\n			http.Error(w, \"403 forbidden\", http.StatusForbidden)\n			return\n		}\n\n		ctx := context.WithValue(r.Context(), \"user_id\", user_id)\n\n		handler(w, r.WithContext(ctx))\n	}\n}\n\nfunc main() {\n	log.Print(\"Starting the server on :8080\")\n	http.HandleFunc(\"/generate\", authMiddleware(generate))\n\n	log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\nWrite a JSON object that describes that will be used to generate the reference of the file.\nThe string inside the JSON must be plain text, and not contain any markdown or HTML.\nWrite as much example code as you can, and make sure to include comments that explain what the code does.\nInclude all the possible errors that can occur.\nOnly add the references of things that are defined in the file. Don't include imports or dependencies.\nDon't forget to make it so all the examples are runnable from the root of the project (This file path: `root/{path}`). YOU SHOULD NOT ASSUME THE USER IS ANYWHERE ELSE THAN THE ROOT DIRECTORY.\nTo launch from the root directory, if the project contains multiple modules (which is clear by the fact that the lib/src path is not directly a child of the root directory), use the most standard way of running it. For example, in python you should use `python -m <module>`, in rust you should use `cargo run --bin <bin>`, etc...\nIf the project doesn't appear to use modules and the code is directly in the root directory, don't use the module/bin.\nFor example, a file located at `root/src/main.rs` should be runnable with `cargo run` from the root directory while a file located at `root/module-a/src/main.rs` should be runnable with `cargo run --bin module-a` from the root directory.\nIf some command line arguments are defined in the file, don't forget to include them in the example. If the command line tool is not clear, replace it with <base_command>. (e.g. `<base_command> --arg1 path1`)\nThe example should contain the command and command lines arguments only if the file is clearly defining a cli command or argument. If it is clearly related to CLI, don't forget to include the command line usage in the example as a bash program. You can use <base_command> is the base command is not defined in the file.\nALL THE CLI COMMANDS USAGE DEFINED SHOULD BE EXPLICITLY WRITTEN IN THE EXAMPLES IN A COMMENTED BASH PROGRAM.\n\nPlease only provide the JSON in a single json markdown code block with the keys described above. Do not include any other text.\nIf the content is not code or doesn't define anything, just return \"None\" and nothing else.\nIf at least one function is defined, you're not allowed to return None.\nYou must include all the functions defined in the reference.\nPlease make sure the JSON is a single line and does not contain any newlines outside of the strings.\n", 1000))
	fmt.Printf("%v\n", b_splits)
}
