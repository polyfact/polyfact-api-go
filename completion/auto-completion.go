package completion

import (
	_ "embed"
	"strings"
	"unicode"

	options "github.com/polyfire/api/llm/providers/options"
)

/*
	When using the auto-completion feature, the model never starts with a space even
	when it should. To deal with that issue we intercept the first word generated by
	the model, concatenate it to the the last word of the prompt and check if it's
	in a list of 10000 english common words. If not, we add a space before it.

	This solution does not work with languages other than english and will struggle
	with words that can be both like "there/by". A later solution could involve
	using a word transition probability table of a markov model (which would still
	not work in multiple languages or with uncommon words and would likely be very
	heavy) or using another LLM to compare the probabilities of the two possibilities.
*/

//go:embed 10000-english-words.txt
var englishWordsListString string

var englishWordsSet = getSetFromWordListString()

func getSetFromWordListString() map[string]bool {
	words := strings.Split(englishWordsListString, "\n")

	wordSet := map[string]bool{}

	for _, word := range words {
		wordSet[word] = true
	}

	return wordSet
}

func AddSpaceIfNeeded(prompt string, input chan options.Result) chan options.Result {
	output := make(chan options.Result)
	lastPromptWordSeparatorIndex := -1

	// We need to convert to runes to support UTF-8. If we don't, unicode letters
	// will be split into multiple chunks and IsLetter will only  work on ascii
	// characters
	promptRunes := []rune(prompt)

	for i := len(promptRunes) - 1; i >= 0; i-- {
		if !unicode.IsLetter(promptRunes[i]) {
			lastPromptWordSeparatorIndex = i
			break
		}
	}

	lastPromptWord := prompt[lastPromptWordSeparatorIndex+1:]

	go func() {
		defer close(output)
		firstOutputWord := <-input

		// We need to skip leading empty results in the case there's a warning sent
		// before any result.
		for firstOutputWord.Result == "" {
			output <- firstOutputWord
			firstOutputWord = <-input
		}

		if _, ok := englishWordsSet[strings.ToLower(lastPromptWord+firstOutputWord.Result)]; !ok {
			firstOutputWord.Result = " " + firstOutputWord.Result
		}

		output <- firstOutputWord

		for v := range input {
			output <- v
		}
	}()

	return output
}
